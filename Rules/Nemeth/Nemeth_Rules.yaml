---
-
   name: default
   tag: msqrt
   match: "."
   variables: [NestingChars: "NestingChars(., '⠨')"]
   replace: 
    - x: $NestingChars                      # start root indicator(s)
    - t: "⠜"
    - x: "*"
    - x: $NestingChars                      # end root indicator(s)
    - t: "⠻"

-
   name: default
   tag: mroot
   match: "."
   variables: [NestingChars: "NestingChars(., '⠨')"]
   replace: 
    - x: $NestingChars                      # start root indicator(s)
    - t: "⠣"
    - x: "*[2]"
    - t: "⠜"                                # end of index
    - x: "*[1]"
    - x: $NestingChars                      # end root indicator(s)
    - t: "⠻"
        
               
# Fraction rules
   # The fraction part of a mixed number is always simple
   # They also differ because a two character sequence is needed to bracket the fraction
   # The invisible plus should produce an empty string

   # Mixed numbers can also use linear form. E.g., 3 1/2
-
   name: linear-mixed-number
   tag: mrow
   match:
      - "preceding-sibling::*[1][self::m:mo][text()='\u2064'] and" # preceding element is invisible plus
      - "*[2][self::m:mo][text() = '/']"                          # not really needed because invisible plus added only if true, but checking
   replace: 
    - t: "⠸⠹"
    - x: "*"
    - t: "⠸⠼"

-
   name: common-fraction-mixed-number
   tag: mfrac
   match:
      - "preceding-sibling::*[1][self::m:mo][text()='\u2064'] and" # preceding element is invisible plus
      - "*[1][self::m:mn][not(contains(., '.'))]   and" 
      - "*[2][self::m:mn][not(contains(., '.'))]"
   replace: 
    - t: "⠸⠹"
    - x: "*[1]"
    - test:
         if: "@bevelled"
         then: [t: "⠸⠌"]
         else: [t: "⠌"]
    - x: "*[2]"
    - t: "⠸⠼"

-
   name: default
   tag: mfrac
   match: "."
   variables: [NestingChars: "NestingChars(., '⠠')"]
   replace: 
    - x: $NestingChars                      # start fraction indicator(s)
    - t: "⠹"
    - x: "*[1]"
    - x: $NestingChars                      # over indicator(s)
    - test:
         if: "@bevelled"
         then: [t: "⠸⠌"]
         else: [t: "⠌"]
    - x: "*[2]"
    - x: $NestingChars                      # end fraction indicator(s)
    - t: "⠼"


#
# Matrix/Determinant rules
# matrix and determinant are the same other than "matrix"/"determinant" based on the bracketing chars
# we don't do spatial layout, instead the beginning/ending of each row uses the enlarged bracketing chars
-
   name: default-matrix
   tag: mrow
   variables:
      - RowStart: "*[1]"
      - RowEnd: "*[3]"
   match:
      - "*[2][self::m:mtable] and"
      - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|'))
   replace: [x: "*[2]"]
-
   name: default-mtable
   tag: mtable
   match: "."
   replace: [x: "*"]
-
  name: default
  tag: [mtr, mlabeledtr]
  match: "."
  replace:
   - test: 
      if: "count(parent::*) > 1"
      then: [t: "⠠"]
   - t: ""
   - x: $RowStart
   - test:
      if: .[self::m:mlabeledtr]
      then:
         - t: "⠗⠕⠺⠀⠇⠁⠃⠑⠇⠸⠒"  # "row label:"
         - x: "*[1]/*"           # contents of row label
   - test:
      if: .[self::m:mlabeledtr]
      then: [x: "*[position()>1]"]
      else: {x: "*"}
   - test: 
      if: "count(parent::*) > 1"
      then: [t: "⠠"]
   - x: $RowEnd
-
  name: default
  tag: mtd
  match: "."
  replace:
   - test: 
      if: "preceding-sibling::*"
      then: [t: "⠀"]
   - x: "*"

-
   name: default
   tag: math
   match: "."
   variables:
      - RowStart: "''"           # empty string -- it needs to be set
      - RowEnd: "''"             # empty string -- it needs to be set
      - NewScriptContext: "''"    # empty string -- it needs to be set
      - NewUnderContext:  "''"    # empty string -- it needs to be set
      - NewOverContext:   "''"    # empty string -- it needs to be set
   replace: [x: "*"]

-
   name: binomial-frac
   tag: mrow
   match: "IsBracketed(., '(', ')') and *[2][self::m:mfrac][@linethickness=0]"
   replace: 
   - x: "*[1]"
   - x: "*[2]/*[1]"
   - t: "⠩"
   - x: "*[2]/*[2]"
   - x: "*[3]"

-
   name: vertical bars
   # 177.vii requires a multipurpose indicator between consecutive vertical bars
   tag: mrow
   match:
      - "( IsBracketed(., '', '|') or IsBracketed(., '', '‖') or IsBracketed(., '', '⦀') ) and "   # ends with single, double, or triple vertical bar
      - "following-sibling::*[1][self::m:mo and text()='\u2062'] and"
      - "(  IsBracketed(following-sibling::*[2], '|', '') or " # starts with ... vertical bar
      - "   IsBracketed(following-sibling::*[2], '‖', '') or "
      - "   IsBracketed(following-sibling::*[2], '⦀', '')  "
      - ")"
   replace:
      - x: "*"
      - t: "m"

-
   name: default
   tag: mrow
   match: "."
   replace: [x: "*"]

-
   # need to deal with numeric indicator
   # part of SRE test
      # "not(@font) or @font=\"normal\" or @font=\"fullwidth\" or @font=\"monospace\"",
      # "not(ancestor::sqrt)",
      # "not(ancestor::root)",
      # "not(ancestor::fraction)",
   name: default
   tag: mn
   match: "."
   replace: [x: "NemethChars(.)"]

-
   # Rule 138 a.2 -- space after a function name
   # most functions will have an invisible apply that adds the space, but "mod" and "rem" are infix, so different
   name: mod_and_rem
   tag: [mi, mo, mtext]    # should really only be 'mo', but others are used
   match: "text()='mod' or text()='rem'"
   replace:
      - x: "NemethChars(.)"
      - t: "⠀"

-
   name: prefix-geometry-ops
   tag: mo
     # add space after these ops when they are prefix operators
   match:
      - "parent::*[count(*) = 2 and name()='mrow' and not(preceding-sibling::*)] and"
      - "IsInDefinition(., 'GeometryPrefixOperators')"
   replace:
      - x: "text()"
      - t: "⠀"

-
   name: default
   tag: mo
     # add spaces around comparison operators,
     # but if "modified", they are moved outside of munder, etc, and handled by those rules
   variables: [AddSpaces: "parent::*[self::m:mrow] and IsInDefinition(., 'NemethComparisonOps')"]
   match: "."
   replace:
      - test:
         if: "$AddSpaces and preceding-sibling::*"
         then: [t: "⠀"]
      - x: "NemethChars(.)"
      - test:
         if: "$AddSpaces and following-sibling::*"
         then: [t: "⠀"]

-
   name: default
   tag: [mi, mtext]
   match: "."
   replace:
      - x: "NemethChars(.)"
      

# -
#    name: default
#    tag: ms
#    match: "."
#    replace: 
#     - t: the string
#     - pause: short
#     - x: text()
-
   name: default
   tag: mstyle
   match: "."
   replace: [x: "*"]

-
   # primes don't get a superscript indicator
   name: prime
   tag: msup
   match: "*[2][self::m:mo][text()='′' or text()='″' or text()='‴' or text()='⁗']"
   replace: 
    - x: "*"
-
   name: default
   tag: msup
   match: "."
   variables: [OldScriptContext: "$NewScriptContext"]
   replace: 
    - x: "*[1]"
    - with:
         variables: [NewScriptContext: "concat($OldScriptContext, '⠘')"]
         replace:
            - x: "$NewScriptContext"
            - x: "*[2]"
    - test:
         # emit level indicator if something follows or the closest non-mrow is an element with a close tag [80(a)]
         # if: "count(following-sibling::*) > 0 or ancestor::*[name() != 'mrow'][1]/.[self::m:mfrac or self::m:msqrt or self::m:mroot]"
         if: "true()"   # FIX 
         then_test:
            if: "$OldScriptContext = ''"
            then: [t: "b"]
            else: [x: "$OldScriptContext"]

-
   # implement rule 77 -- simple numeric (non-nested) subscript: don't use a subscript indicator
   #   must be a subscript at level 1
   # also rule 177.3 for multipurpose indicator (might be removed)
   name: numeric-sub
   tag: msub
   match: "*[2][self::m:mn] and ($NewScriptContext = '') and 
           *[1][BaseNode(.)[self::m:mi]]"
   replace:
      - x: "*[1]"
      - t: "M"                # multipurpose indicator prevents the 'letter digit' substitution (177.2) from kicking in
      - x: "*[2]"
      - test:
         if: "count(following-sibling::*) > 0 and not($NewScriptContext)"
         then: [t: "M"]

-
   name: default
   tag: msub
   match: "."
   variables: [OldScriptContext: "$NewScriptContext"]
   replace: 
    - x: "*[1]"
    - with:
         variables: [NewScriptContext: "concat($OldScriptContext, '⠰')"]
         replace:
            - x: "$NewScriptContext"
            - x: "*[2]"
    - test:
         if: "true()"   # FIX 
         then_test:
            if: "$OldScriptContext"
            then: [x: "$OldScriptContext"]
            else: [t: "b"]

-
   # primes don't get a superscript indicator and come before the subscript
   name: prime
   tag: msubsup
   variables: [OldScriptContext: "$NewScriptContext"]
   match: "*[3][self::m:mo][text()='′' or text()='″' or text()='‴' or text()='⁗']"
   replace: 
    - x: "*[1]"
    - x: "*[3]"
    - test:
         if: "*[2][self::m:mn] and ($NewScriptContext = '') and 
              *[1][BaseNode(.)[self::m:mi]]"
         then:
            - x: "*[2]"
            - test:
               if: "count(following-sibling::*) > 0 and not($NewScriptContext)"
               then: [t: "M"]
         else:
            - with:
                  variables: [NewScriptContext: "concat($OldScriptContext, '⠰')"]
                  replace:
                     - x: "$NewScriptContext"
                     - x: "*[2]"
            - test:
                  if: "true()"   # FIX 
                  then_test:
                     if: "$OldScriptContext"
                     then: [x: "$OldScriptContext"]
                     else: [t: "b"]


-
   name: default
   tag: msubsup
   match: "."
   variables:
    - OldScriptContext: "$NewScriptContext"
    - IsPrime: "*[3][self::m:mo][text()='′' or text()='″' or text()='‴' or text()='⁗']"
    - IsNumericSubscript: "*[2][self::m:mn] and ($NewScriptContext = '') and 
                           *[1][BaseNode(.)[self::m:mi]]"
   replace: 
    - x: "*[1]"
    - with:
         variables: [NewScriptContext: "concat($OldScriptContext, '⠰')"]
         replace:
            - test:
               if: "$IsNumericSubscript"
               then: [t: "M"]      # multipurpose indicator prevents the 'letter digit' substitution (177.2) from kicking in
               else: [x: "$NewScriptContext"]
            - x: "*[2]"
    - with:
         variables: [NewScriptContext: "concat($OldScriptContext, '⠘')"]
         replace:
            - x: "$NewScriptContext"
            - x: "*[3]"
    - test:
         if: "true()"   # FIX 
         then_test:
            if: "$OldScriptContext"
            then: [x: "$OldScriptContext"]
            else: [t: "b"]

-
   name: default
   tag: munder
   match: "."
   variables:
    - NotNested: "$NewUnderContext='' and $NewOverContext=''"
    - OldUnderContext: "$NewUnderContext"
    - NewUnderContext: "concat($NewUnderContext, '⠩')"
   replace: 
    - test:
         if: "$NotNested"
         then: [t: "⠐"]
    - x: "*[1]"
    - x: "$NewUnderContext"
    - x: "*[2]"
    - test:
         if: "$NotNested"
         then: [t: "⠻"]

-
   name: contracted-form #rule 86.b
   tag: mover
   match: "*[1][string-length(text())=1] and *[2][text()='¯']"
   replace: 
    - x: "*"

-
   name: default
   tag: mover
   match: "."
   variables:
    - NotNested: "$NewUnderContext='' and $NewOverContext=''"
    - OldOverContext: "$NewOverContext"
    - NewOverContext: "concat($NewOverContext, '⠣')"
    - AddSpaces: "IsInDefinition(BaseNode(.), 'NemethComparisonOps')"

   replace: 
    - test:
         if: "$AddSpaces"
         then: [t: "⠀"]
    - test:
         if: "$NotNested"
         then: [t: "⠐"]
    - x: "*[1]"
    - x: "$NewOverContext"
    - x: "*[2]"
    - test:
         if: "$NotNested"
         then: [t: "⠻"]
    - test:
         if: "$AddSpaces"
         then: [t: "⠀"]
    
-
   name: default
   tag: munderover
   match: "."
   variables:
    - NotNested: "$NewUnderContext='' and $NewOverContext=''"
    - OldUnderContext: "$NewUnderContext"
    - NewUnderContext: "concat($NewUnderContext, '⠩')"
    - OldOverContext: "$NewOverContext"
    - NewOverContext: "concat($NewOverContext, '⠣')"
   replace: 
    - test:
         if: "$NotNested"
         then: [t: "⠐"]
    - x: "*[1]"
    - x: "$NewUnderContext"
    - x: "*[2]"
    - x: "$NewOverContext"
    - x: "*[3]"
    - test:
         if: "$NotNested"
         then: [t: "⠻"]

# -
  # Note: @notation can contain more than one value
  # The ordering below is the order in which words come out when there is more than one value
  # 
  #  name: default
  #  tag: menclose
  #  match: "."
  #  replace:
  #   - test:
  #       if: ". [contains(concat(' ', normalize-space(@notation), ' '), ' box ')]"
  #       then: [t: box, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'roundedbox')]"
  #       then: [t: round box, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'circle')]"
  #       then: [t: circle, pause: short]
  #   - test:
  #       if: ".[ contains(concat(' ', normalize-space(@notation), ' '), ' left ') or 
  #               contains(concat(' ', normalize-space(@notation), ' '), ' right ') or 
  #               contains(@notation,'top') or contains(@notation,'bottom') ]"
  #       then:
  #         - t: line on
  #         - test:
  #             if: ".[contains(concat(' ', normalize-space(@notation), ' '), ' left ')]"
  #             then: [t: left, pause: short]
  #         - test:
  #             if: ".[contains(concat(' ', normalize-space(@notation), ' '), ' right ')]"
  #             then: [t: right, pause: short]
  #         - test:
  #             if: ".[contains(@notation,'top')]"
  #             then: [t: top, pause: short]
  #         - test:
  #             if: ".[contains(@notation,'bottom')]"
  #             then: [t: bottom, pause: short]
  #   - test:
  #       if: ".[ contains(@notation,'updiagonalstrike') or contains(@notation,'downdiagonalstrike') or 
  #               contains(@notation,'verticalstrike') or contains(@notation,'horizontalstrike') ]"
  #       then:
  #         - test:
  #             if: ".[contains(@notation,'updiagonalstrike') and contains(@notation,'downdiagonalstrike')]"
  #             then: [spell: x, pause: short]  # seems better to say 'x cross out' than 'up diagonal, down diagonal cross out'
  #             else:
  #               - test:
  #                   if: ".[contains(@notation,'updiagonalstrike')]"
  #                   then: [t: up diagonal, pause: short]
  #               - test:
  #                   if: ".[contains(@notation,'downdiagonalstrike')]"
  #                   then: [t: down diagonal, pause: short]
  #         - test:
  #             if: ".[contains(@notation,'verticalstrike')]"
  #             then: [t: vertical, pause: short]
  #         - test:
  #             if: ".[contains(@notation,'horizontalstrike')]"
  #             then: [t: horizontal, pause: short]
  #         - t: cross out
  #         - pause: short
  #   - test:
  #       if: ".[contains(@notation,'uparrow')]"
  #       then: [t: up arrow, pause: short]
  #   - test:
  #       if: ".[contains(concat(' ', normalize-space(@notation), ' '), ' downarrow ')]"
  #       then: [t: down arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'leftarrow')]"
  #       then: [t: left arrow, pause: short]
  #   - test:
  #       if: ".[contains(concat(' ', normalize-space(@notation), ' '), ' rightarrow ')]"
  #       then: [t: right arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'northeastarrow')]"
  #       then: [t: northeast arrow, pause: short]
  #   - test:
  #       if: ".[contains(concat(' ', normalize-space(@notation), ' '), ' southeastarrow ')]"
  #       then: [t: southeast arrow, pause: short]
  #   - test:
  #       if: ".[contains(concat(' ', normalize-space(@notation), ' '), ' southwestarrow ')]"
  #       then: [t: southwest arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'northwestarrow')]"
  #       then: [t: northwest arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'updownarrow')]"
  #       then: [t: double ended vertical arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'leftrightarrow')]"
  #       then: [t: double ended horizontal arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'northeastsouthwestarrow')]"
  #       then: [t: double ended up diagonal arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'northwestsoutheastarrow')]"
  #       then: [t: double ended down diagonal arrow, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'actuarial')]"
  #       then: [t: actuarial symbol, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'madrub')]"
  #       then: [t: arabic factorial symbol, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'phasorangle')]"
  #       then: [t: phasor angle, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'longdiv') or not(@notation) or normalize-space(@notation) ='']"      # default
  #       then: [t: long division symbol, pause: short]
  #   - test:
  #       if: ".[contains(@notation,'radical')]"
  #       then: [t: square root, pause: short]
  #   - t: enclosing
  #   - x: "*"
  #   - test:
  #       if: "$Impairment = 'Blindness' and ( $SpeechStyle != 'SimpleSpeak' or not(IsNode(*[1], 'leaf')) )"
  #       then: [t: end enclosure]
  #   - pause: short



-
   name: default-children
   tag: unknown
   match: count(*)>1
   replace: 
    - t: unknown math m l element
    - x: text()
-
   name: default-empty
   tag: unknown
   match: "*[not(text())]"
   replace: 
    - t: empty unknown math m l element
    - x: text()
-
   name: default-text
   tag: unknown
   match: "."
   replace: 
    - t: unknown math m l element
    - x: text()