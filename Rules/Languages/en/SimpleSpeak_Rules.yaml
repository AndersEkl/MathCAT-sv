---

-
   name: default
   tag: square-root
   match: "."
   replace: 
   - test: 
      if: "$Verbosity!='Terse'"
      then: {t: the}
   - t: square root
   - test: 
      if: "$Verbosity!='Terse'"
      then: {t: of}
      else: {pause: short}
   - x: "*[1]"
   - test: 
      if: IsNode(*[1], 'leaf')
      then: [pause: short]
      else: [t: end root, pause: short]

-
   name: default
   tag: root
   match: "."
   replace: 
   - test: 
      if: "$Verbosity!='Terse'"
      then: [t: the]
   - test:
      if: "*[2][self::m:mn]"
      then_test:
      - if: "*[2][text()='2']"
        then: [t: square root]
      - else_if: "*[2][text()='3']"
        then: [t: cube root]
      - else_if: "*[2][not(contains(., '.'))]"
        then: [x: "ToOrdinal(*[2])", t: root]
      else:
      - test:
         if: "*[2][self::m:mi][string-length(.)=1]"
         then:
         - x: "*[2]"
         - pronounce: [text: "-th", ipa: "θ", sapi5: "th", eloquence: "T"]
         else: [x: "*[2]"]
      - t: root
   - test: 
      if: "$Verbosity!='Terse'"
      then: [t: of]
   - x: "*[1]"
   - test: 
      if: IsNode(*[1], 'leaf')
      then: [pause: short]
      else: [t: end root, pause: short]
        
               
# Fraction rules
# Mixed numbers mostly "just work" because the invisible char reads as "and" and other parts read properly on their own
-
   name: common-fraction
   tag: fraction
   match:
   - "*[1][self::m:mn][not(contains(., '.')) and text()<20]   and" 
   - "*[2][self::m:mn][not(contains(., '.')) and 2<= text() and text()<=10]"
   replace: [x: ToCommonFraction(.)]
-
   name: common-fraction-mixed-number
   tag: fraction
   match:
   - "preceding-sibling::*[1][self::m:mo][text()='\u2064'] and" # preceding element is invisible plus
   - "*[1][self::m:mn][not(contains(., '.'))]   and" 
   - "*[2][self::m:mn][not(contains(., '.'))]"
   replace: [x: ToCommonFraction(.)]
-
   # don't include nested fractions. E.g, fraction a plus b over c + 1 end fraction" is ambiguous
   # by simplistic SimpleSpeak's rules "b over c" is a fraction, but if we say nested fractions
   # are never simple, then any 'over' applies only to enclosing "fraction...end fraction" pair.
   name: simple
   tag: fraction
   match:
   - "(IsNode(*[1],'leaf') and IsNode(*[2],'leaf')) and"
   - "not(ancestor::*[name() != 'mrow'][1]/self::m:fraction)"    # FIX: can't test for mrow -- what should be used???
   replace: 
   - x: "*[1]"
   - t: over
   - x: "*[2]"
   - pause: short

-
   name: default
   tag: fraction
   match: "."
   replace: 
   - t: fraction
   - pause: short
   - x: "*[1]"
   - test:
      if: "not(IsNode(*[1],'leaf'))"
      then: [pause: short]
   - t: over
   - test:
      if: "not(IsNode(*[2],'leaf'))"
      then: [pause: short]
   - x: "*[2]"
   - pause: short
   - t: end fraction
   - pause: medium

# rules for functions raised to a power
# these could have been written on 'mrow' but putting them on msup seems more specific
# to see if it is a function, we look right to see if the following sibling is apply-function
-
   name: inverse-function
   tag: inverse-function
   match: "."
   replace:
      - t: inverse
      - x: "*[1]"

-
   name: function-squared-or-cubed
   tag: power
   match:
    - "*[2][self::m:mn][text()='2' or text()='3'] and"
    - "following-sibling::*[1][self::m:mo][text()='\u2061']"  #invisible function apply
   replace:
    - x: "*[1]"
    - bookmark: "*[2]/@id"
    - test: 
         if: "*[2][text()=2]"
         then: {t: squared}
         else: {t: cubed}
-
   name: function-power
   tag: power
   match:
    - "following-sibling::*[1][self::m:mo][text()='\u2061']"  #invisible function apply
   replace:
    - test: 
         if: "$Verbosity!='Terse'"
         then: {t: the}
    - bookmark: "*[2]/@id"     
    - test:
         if: "*[2][self::m:mn][not(contains(., '.'))]"
         then: [x: "ToOrdinal(*[2])"]
         else: [x: "*[2]"]
    - t: power of
    - pause: short
    - x: "*[1]"

# non-function rules for power
-
   name: squared-or-cubed
   tag: power
   match: "*[2][self::m:mn][text()='2' or text()='3']"
   replace:
    - x: "*[1]"
    - bookmark: "*[2]/@id"
    - test: 
         if: "*[2][text()=2]"
         then: {t: squared}
         else: {t: cubed}

-
   name: simple-integer
   tag: power
   match: "*[2][self::m:mn][not(contains(., '.'))]"
   replace: 
   - x: "*[1]"
   - t: to the
   - test: 
      if: "*[2][.>0]"
      then: {x: "ToOrdinal(*[2])"}
      else: {x: "*[2]"}
-
   name: simple-negative-integer
   tag: power
   match: 
   - "*[2][self::m:negative and"
   - "     *[1][self::m:mn][not(contains(., '.'))]]"
   replace: 
   - x: "*[1]"
   - t: to the
   - x: "*[2]"
-
   name: simple-var
   tag: power
   match: "*[2][self::m:mi][string-length(.)=1]"
   replace: 
   - x: "*[1]"
   - t: to the
   - x: "*[2]"
   - pronounce: [text: "-th", ipa: "θ", sapi5: "th", eloquence: "T"]

-
   name: simple
   tag: power
   match: "IsNode(*[2], 'leaf')"
   replace: 
   - x: "*[1]"
   - t: to the
   - x: "*[2]"
-
   # ending nested exponents with "...power power" sounds bad
   # it won't end in "power" if the exponent is simple enough
   # FIX: not that important, but this misses the case where the nested exp is a negative integer (change test if this is fixed)
   name: nested
   tag: power
   match:
   - "*[2]["
   - "     (self::m:power and not(IsNode(*[2], 'leaf'))) or"                  # non-simple nested superscript
   - "     self::m:mrow[*[last()][self::m:power[not(IsNode(*[2], 'leaf'))]]]" # same as above but at the end of an mrow # FIX: need to figure out linear replacement
   - "    ]"
   replace: 
   - x: "*[1]"
   - t: raised to the
   - x: "*[2]"
   - pause: short
   - t: end exponent
-
   name: default
   tag: power
   match: "."
   replace: 
   - x: "*[1]"
   - t: raised to the
   - x: "*[2]"
   - t: power

#
# Some rules on mrows
#
-
   name: set
   tag: set
   match: "."
   replace: 
   - test: 
      - if: "count(*)=0"
        then:
         - test: 
            if: "$Verbosity!='Terse'"
            then: {t: the}
         - t: empty set
      - else_if: "count(*[1]/*)=3 and *[1]/*[2][self::m:mo][text()=':' or text()='|' or text()='∣']"
        then:
         - test: 
            if: "$Verbosity!='Terse'"
            then: {t: the}
         - t: set of all
         - x: "*[1]/*[1]"
         - t: such that
         - x: "*[1]/*[3]"
        else:
         - test: 
            if: "$Verbosity!='Terse'"
            then: {t: the}
         - t: set 
         - x: "*[1]"


#
# Matrix/Determinant rules
# matrix and determinant are the same other than "matrix"/"determinant" based on the bracketing chars
# the pausing logic is pushed down to the <mtd>
# the rules either speak the <mtr>s (to get "row n") or the <mtd>s. "column n" spoken if $IsColumnSilent is false
-
   name: 1x1-matrix
   tag: mrow
   variables: [IsColumnSilent: "true()"]
   match:
   - "*[2][self::m:mtable] and"
   - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
   - count(*[2]/*)=1 and count(*[2]/*[self::m:mtr][1]/*)=1
   replace:
   - ot: the
   - t: 1 by 1
   - test:
      if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
      then: {t: determinant}
      else: {t: matrix}
   - t: with entry
   - x: "*[2]/*[1]/*"

# simpler reading methods for smaller matrices if the entries are simple
-
  name: 2-or-3x1-matrix
  tag: mrow
  variables: [IsColumnSilent: true()]
  match:
    - "*[2][self::m:mtable] and"
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*[1]/*)=1 and    # one column
    - count(*[2]/*)<=3 and   # at least two rows
    - IsNode(*[2]/*/*/*,'simple')   # IsNode() returns true if all the nodes are simple
  replace: 
    - t: the
    - x: count(*[2]/*)
    - t: by 1 column matrix
    - pause: long
    - x: "*[2]/*/*"
    - t: end matrix

-
  name: default-column-matrix
  tag: mrow
  variables: [IsColumnSilent: true()]
  match:
    - "*[2][self::m:mtable] and"
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*[1]/*)=1
  replace: 
    - t: the
    - x: "count(*[2]/*)"
    - t: by 1 column matrix
    - pause: long
    - x: "*[2]/*"     # select the rows (mtr)
    - t: "end matrix"

-
  name: 1x2-or-3-matrix
  tag: mrow
  variables: [IsColumnSilent: true()]
  match:
    - "*[2][self::m:mtable] and"
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*)=1  and          # one row
    - count(*[2]/*[1]/*)<=3 and   # at least two cols
    - IsNode(*[2]/*/*/*,'simple')   # IsNode() returns true if all the nodes are simple
  replace: 
    - t: the 1 by
    - x: count(*[2]/*/*)
    - t: row matrix
    - pause: long
    - x: "*[2]/*/*"
    - t: end matrix
 
-
  name: default-row-matrix
  tag: mrow
  variables: [IsColumnSilent: false()]
  match:
    - "*[2][self::m:mtable] and"
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - count(*[2]/*)=1         # one row
  replace: 
    - t: the 1 by
    - x: "count(*[2]/*/*)"
    - t: row matrix
    - pause: long
    - pause: medium
    - x: "*[2]/*/*"     # select the cols (mtd)
    - t: "end matrix"

-
  name: simple-small-matrix
  tag: mrow
  match:
    - "*[2][self::m:mtable] and"
    - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')) and
    - (count(*[2]/*)<=3 and count(*[2]/*[1]/*)<=3) and       # no bigger than a 3x3 matrix
    - IsNode(*[2]/*/*/*,'simple')         # IsNode() returns true if all the nodes are simple
  variables: [IsColumnSilent: true()]
  replace: 
    - t: the
    - x: count(*[2]/*)
    - t: by
    - x: count(*[2]/*[self::m:mtr][1]/*)
    - test:
        if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
        then: {t: determinant}
        else: {t: matrix}
    - pause: long
    - x: "*[2]/*"
    - t: end matrix
 
-
   name: default-matrix
   tag: mrow
   variables: [IsColumnSilent: false()]
   match:
   - "*[2][self::m:mtable] and"
   - (IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|'))
   replace: 
    - t: the
    - x: "count(*[2]/*)"
    - t: by
    - x: "count(*[2]/*[self::m:mtr][1]/*)"
    - test:
        if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
        then: {t: determinant}
        else: {t: matrix}
    - pause: long
    - x: "*[2]/*"
    - t: end
    - test:
        if: "*[1][text()='|']"    # just need to check the first bracket since we know it must be (, [, or |
        then: {t: determinant}
        else: {t: matrix}
-
  name: default
  tag: [mtr, mlabeledtr]
  match: "parent::m:matrix or parent::m:determinant"
  replace:
   - t: row
   - x: "count(preceding-sibling::*)+1"
   - test:
      if: .[self::m:mlabeledtr]
      then:
         - t: with label
         - x: "*[1]/*"
         - pause: short
   - pause: medium
   - test:
      if: .[self::m:mlabeledtr]
      then: [x: "*[position()>1]"]
      else: {x: "*"}
-
  name: default
  tag: mtd
  match: "parent::*[parent::m:matrix or parent::m:determinant]"
  replace:
   - test: 
      if: "not($IsColumnSilent)"
      then:
         - t: column
         - x: "count(preceding-sibling::*)+1"
         - pause: medium
   - x: "*"
   - test:
      # short pause after each element; medium pause if last element in a row; long pause for last element in matrix
      - if: count(following-sibling::*) > 0
        then: {pause: short}
      - else_if: count(../following-sibling::*) > 0
        then: {pause: medium}
        else: {pause: long}
 

-
   name: times
   tag: mo
   match:
      # say "times" when invisible times is followed by parens or a superscript that has a base with parens or "|"s
      # if we aren't sure if it is times or not, don't say anything
   - "text()='\u2062' and @data-guess and ("
      - "  following-sibling::*[1][" 
      - "    IsBracketed(., '(', ')') or IsBracketed(., '[(]', ']') or IsBracketed(., '|', '|') or self::m:binomial or"  # followed by parens
      - "    ( (self::m:msup or self::m:msub or self::m:msubsup or self::m:power) and "               # followed by msup, etc.
      - "       *[1][self::m:mrow][IsBracketed(., '(', ')') or IsBracketed(., '[(]', ']') or IsBracketed(., '|', '|')]"  # base has parens
      - "    )"
      - "  ]"
       # other possibility is the preceding element has parens (but not the following)
      - " or "  
      - "  preceding-sibling::*[1][" 
      - "    IsBracketed(., '(', ')') or IsBracketed(., '[(]', ']') or IsBracketed(., '|', '|')]"  # followed by parens
      - " )"
   replace:
      - t: times

-
   name: no-say-parens
   tag: mrow
   match:
   - "parent::*[not(self::m:msup) and not(self::m:msub) and not(self::m:msubsup) and not(self::m:power)] and "
   - "( IsBracketed(., '(', ')') or IsBracketed(., '[', ']') ) and "
   - "( IsNode(*[2], 'simple')  )"
      # missing clause: 'a positive fraction that is spoken as an ordinal
      #   (either by the Ordinal preference or by the default rules_'
   replace:
   - x: "*[2]"

-
   include: "SharedRules/geometry.yaml"
-
   include: "SharedRules/linear-algebra.yaml"
-
   include: "SharedRules/general.yaml"
-
   include: "SharedRules/default.yaml"