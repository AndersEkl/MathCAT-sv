use crate::errors::*;
use sxd_document::dom::*;
use sxd_document::QName;
use phf::{phf_map, phf_set};
use std::collections::HashMap;
extern crate lazy_static;
use crate::xpath_functions::IsBracketed;
use std::{ptr::eq as ptr_eq};
use std::cell::RefCell;
use std::rc::Rc;

// FIX: DECIMAL_SEPARATOR should be set by env, or maybe language
const DECIMAL_SEPARATOR: &'static str = ".";
const CHANGED_ATTR: &'static str = "data-changed";
const ADDED_ATTR_VALUE: &'static str = "added";

fn create_mathml_element<'a>(doc: &Document<'a>, name: &str) -> Element<'a> {
	return doc.create_element(sxd_document::QName::with_namespace_uri(
		Some("http://www.w3.org/1998/Math/MathML"),
		name));
}

// Canonicalize does three things:
// 1. cleans up the tree so all extra white space is removed (should only have element and text nodes)
// 2. calls on the pattern matcher to normalize the characters (and whatever else it does)
// 3. the tree is "parsed" based on the mo (priority)/mi/mn's in an mrow
//	  this adds mrows mrows and some invisible operators (implied times, function app, ...)
//    extra mrows are removed
//    implicit mrows are turned into explicit mrows (e.g, there will be a single child of 'math')
// We are pretty conservative in adding new mrows and won't do it if:
// 1. there is an intent attr
// 2. if the mrow starts and ends with a fence (e.g, French open interval "]0,1[")
// An mrow is never deleted unless it is redundant.
pub fn canonicalize<'a>(mathml: Element<'a>) -> Element<'a> {
	use crate::pretty_print::mml_to_string;
	// println!("MathML before canonicalize:\n{}", mml_to_string(&mathml));
	let converted_mathml = mathml.clone();

	if name(&mathml) != "math" {
		// println!("Didn't start with <math> element -- attempting repair");
		let math_element = create_mathml_element(&converted_mathml.document(), "math");
		math_element.set_attribute_value(CHANGED_ATTR, ADDED_ATTR_VALUE);
		math_element.append_child(converted_mathml);
	}
	converted_mathml.set_name(QName::with_namespace_uri(Some("http://www.w3.org/1998/Math/MathML"), "math"));
	let children = converted_mathml.children();
	if children.len() > 1 {
		// start canonicalization by adding an mrow -- then the rest flows
		let mrow_element = create_mathml_element(&converted_mathml.document(), "mrow");
		mrow_element.set_attribute_value(CHANGED_ATTR, ADDED_ATTR_VALUE);
		mrow_element.append_children(children);
		converted_mathml.append_child(mrow_element);
	}
	let converted_mathml = canonicalize_mrows(converted_mathml);
	match converted_mathml {
		Ok(e) => {
			println!("\nMathML after canonicalize:\n{}", mml_to_string(&e));
			return e;
		},
		Err(e)  => {
			crate::speech::print_errors( &e.chain_err(|| mml_to_string(&mathml)) );
			return mathml;
		},
	};
}

// useful utility functions

fn name<'a>(node: &'a Element<'a>) -> &str {
	return node.name().local_part();
}

// The child of a non-leaf element must be an element
// Note: can't use references as that results in 'returning use of local variable'
fn as_element<'a>(child: ChildOfElement<'a>) -> Element<'a> {
	return match child {
		ChildOfElement::Element(e) => e,
		_ => panic!("as_element: internal error -- found non-element child"),
	}
}

// The child of a leaf element must be text (previously trimmed)
// Note: can't use references as that results in 'returning use of local variable'
fn as_text<'a>(leaf_child: Element<'a>) -> &'a str {
	assert!(name(&leaf_child) == "mi" || name(&leaf_child) == "mo" || name(&leaf_child) == "mn" || name(&leaf_child) == "mtext" ||
			name(&leaf_child) == "ms" || name(&leaf_child) == "mspace" || name(&leaf_child) == "mglyph");
	let children = leaf_child.children();
	if children.len() == 0 {
		return "";
	};
	if children.len() == 1 {
		return match children[0] {
			ChildOfElement::Text(t) => t.text(),
			_ => panic!("as_text: internal error -- found non-text child of leaf element"),	
		}
	};

	// can have mglyph and a few other things inside a leaf -- not sure what should happen.
	// FIX: is returning an empty string always ok???
	return "";
}

#[allow(dead_code)] // for debugging with println
fn is_leaf<'a>(leaf_child: Element<'a>) -> bool {
	return  name(&leaf_child) == "mi" || name(&leaf_child) == "mo" || name(&leaf_child) == "mn" || name(&leaf_child) == "mtext" ||
			name(&leaf_child) == "ms" || name(&leaf_child) == "mspace" || name(&leaf_child) == "mglyph";
}

#[allow(dead_code)] // for debugging with println
fn element_summary<'a>(mathml: Element<'a>) -> String {
	return format!("{}<{}>", name(&mathml), if is_leaf(mathml) {as_text(mathml).to_string()} else {mathml.children().len().to_string()});
}

fn create_mo<'d, 'o>(doc: Document<'d>, op: &'o OperatorInfo) -> Element<'d> {
	let implied_mo = create_mathml_element(&doc, "mo");
	implied_mo.set_attribute_value(CHANGED_ATTR, ADDED_ATTR_VALUE);
	let mo_text = doc.create_text(op.ch);
	implied_mo.append_child(mo_text);
	return implied_mo;
}

fn is_adorned_node<'a>(node: &'a Element<'a>) -> bool {
	let name = name(node);
	return	name == "msub" || name == "msup" || name == "msubsup" ||
			name == "munder" || name == "mover" || name == "munderover" ||
			name == "mmultiscripts";
}


fn get_possible_embellished_node<'a>(node: Element<'a>) -> Element<'a> {
	let mut node = node;
	while is_adorned_node(&node) {
		node = as_element(node.children()[0]);
	}
	return node;
}

#[allow(dead_code)] // for debugging with println
fn show_invisible_op_char<'o>(op: &'o OperatorInfo) -> &'o str {
	return match op.ch.chars().next().unwrap() {
		'\u{2061}' => "&#x2061;",
		'\u{2062}' => "&#x2062;",
		'\u{2063}' => "&#x2063;",
		'\u{2064}' => "&#x2064;",
		'\u{E000}' => "&#xE000;",
		_ 		   => op.ch
	};
}


fn canonicalize_mrows<'a>(mathml: Element<'a>) -> Result<Element<'a>> {
	let tag_name = name(&mathml);
	mathml.set_name(QName::with_namespace_uri(Some("http://www.w3.org/1998/Math/MathML"), tag_name));
	match tag_name {
		"mi" | "ms" | "mtext" | "mspace" | "mglyph" => { return Ok( mathml ); },
		"mo" => {
			canonicalize_mo_text(mathml);
			return Ok( mathml );
		},
		"mn" => {
			// FIX: hack cleanup for mn's that are big numbers composed of digit blocks and ","s (still have mn's and mo's -- see canonicalize.tdl)
			// let bigNumValue;
			// if input->GetAttrValue(L"isBigNumber", bigNumValue)) {
			// 	return StripLeafNodes(input->Copy(True));
			// }
			return Ok( mathml );
		},
		"mrow" => {
			return Ok( canonicalize_mrows_in_mrow(mathml)? );
		},
		_ => {
			// recursively try to make mrows in other structures (eg, num/denom in fraction)
			let mut new_children = Vec::with_capacity(mathml.children().len());
			for child in mathml.children() {
				match child {
					ChildOfElement::Element(e) => {
						new_children.push( ChildOfElement::Element(canonicalize_mrows(e)? ));
					},
					_ => panic!("Should have been an element or text"),
				}
			}
			mathml.replace_children(new_children);
			return Ok( mathml );
		},
	}
}

fn canonicalize_mo_text<'a>(mo: Element<'a>) {
	let parent_name = name(&mo);		// guaranteed to exist
	let mut mo_text = as_text(mo);
	if parent_name == "mover" || parent_name == "munder" || parent_name == "munderover" {
		// canonicalize various diacritics for munder, mover, munderover
		mo_text = match mo_text {
			"\u{02C9}"| "\u{0304}"| "\u{0305}"| "\u{2212}" => "_",
			"\u{02BC}" => "`",
			"\u{02DC}" => "~",
			"\u{02C6}"| "\u{0302}" => "^",
			"\u{02D9}"| "\u{0307}" => ".",
			"\u{0308}" => "Â¨",
			_ => mo_text,
		}
		// FIX: MathType generates the wrong version of union and intersection ops (binary instead of unary)
	}
	mo_text = match mo_text {
		"\u{2212}" => "-",
		"\u{00AF}"| "\u{02C9}"| "\u{0304}"| "\u{0305}" => "_",
		_ => mo_text,
	};
	mo.set_text(mo_text);
}

	bitflags! {
		struct OperatorTypes: u32 {
			const NONE		= 0x0;
			const PREFIX	= 0x1;
			const INFIX		= 0x2;
			const POSTFIX	= 0x4;
			const FENCE		= 0x8;
			const LEFT_FENCE= 0x9;
			const RIGHT_FENCE=0xc;
			const UNSPECIFIED=0xf;		// 'and-ing will match anything
		}
	}


#[derive(Clone, Debug)]
struct OperatorInfo<'o>{
	ch: &'static str,
	op_type: OperatorTypes,
	priority: usize,
	next: Option<&'o OperatorInfo<'o>>,	// can be both prefix & infix (etc) -- chain of options
}

#[derive(Debug)]
struct OperatorVersions<'o>{
	prefix: Option<&'o OperatorInfo<'o>>,
	infix: Option<&'o OperatorInfo<'o>>,
	postfix: Option<&'o OperatorInfo<'o>>,
}

impl<'o> OperatorVersions<'o> {
	fn new(op: &'o OperatorInfo<'o>) -> OperatorVersions<'o> {
		let mut op: &'o OperatorInfo<'o> = op;
		let mut prefix = None;
		let mut infix = None;
		let mut postfix = None;
		loop {
			if op.is_prefix() {
				prefix = Some( op );
			} else if op.is_infix() {
				infix = Some( op )
			} else if op.is_postfix() {
				postfix = Some( op );
			} else {
				panic!("OperatorVersions::new: operator is not prefix, infix, or postfix")
			}
			//let another_op = op.next;
			match op.next {
				None => break,
				Some(alt_op) => op = alt_op,
			}
		}
		return OperatorVersions{prefix, infix, postfix};
	}
}


impl<'o> OperatorInfo<'o> {
	fn is_prefix(&self) -> bool {
		return (self.op_type.bits & OperatorTypes::PREFIX.bits) != 0;
	}

	fn is_infix(&self) -> bool {
		return (self.op_type.bits & OperatorTypes::INFIX.bits) != 0;
	}

	fn is_postfix(&self) -> bool {
		return (self.op_type.bits & OperatorTypes::POSTFIX.bits) != 0;
	}

	fn is_left_fence(&self) -> bool {
		return self.op_type.bits & OperatorTypes::LEFT_FENCE.bits == OperatorTypes::LEFT_FENCE.bits;
	}

	fn is_right_fence(&self) -> bool {
		return self.op_type.bits & OperatorTypes::RIGHT_FENCE.bits ==OperatorTypes::RIGHT_FENCE.bits;
	}

	fn is_operator_type(&self, op_type: OperatorTypes) -> bool {
		return self.op_type.bits & op_type.bits != 0;
	}

	fn is_plus_or_minus(&self) -> bool {
		return ptr_eq(self, *PLUS) || ptr_eq(self, *MINUS);
	}

	fn is_times(&self) -> bool {
		return ptr_eq(self, *IMPLIED_TIMES) || ptr_eq(self, *TIMES_SIGN);
	}

	fn is_nary(&self, previous_op: &'o OperatorInfo) -> bool {
		return	ptr_eq(previous_op,self) ||
				(previous_op.is_plus_or_minus() && self.is_plus_or_minus()) ||
				(previous_op.is_times() && self.is_times());
	}
}


static OPERATORS: phf::Map<&str, OperatorInfo> = include!("operator-info.in");


// The set of fence operators that can being either a left or right fence (or infix). For example: "|".
static AMBIGUOUS_OPERATORS: phf::Set<&str> = phf_set! {
	"|", "||", "\u{2016}"
};

thread_local!{
	// a version of an OPERATOR entry modified by attrs on an <mo> 
	pub static MODIFIED_OPERATORS: RefCell<HashMap<String, OperatorInfo<'o>>> = RefCell::new(HashMap::with_capacity(29));
}


lazy_static!{
	static ref LEFT_FENCEPOST: OperatorInfo<'static> = OperatorInfo{ ch: "\u{E000}", op_type: OperatorTypes::LEFT_FENCE, priority: 0, next: None };

	static ref IMPLIED_TIMES: &'static OperatorInfo<'static> = OPERATORS.get(&"\u{2062}").unwrap();
	static ref IMPLIED_INVISIBLE_PLUS: &'static OperatorInfo<'static> = OPERATORS.get(&"\u{2064}").unwrap();
	static ref INVISIBLE_FUNCTION_APPLICATION: &'static OperatorInfo<'static> = OPERATORS.get(&"\u{2061}").unwrap();

	static ref PLUS: &'static OperatorInfo<'static> = OPERATORS.get(&"+").unwrap();
	static ref MINUS: &'static OperatorInfo<'static> = OPERATORS.get(&"-").unwrap();
	//static ref PREFIX_MINUS: &'static OperatorInfo = verify_prefix_version(&OPERATORS.get(&"-").unwrap().next.unwrap());
	static ref TIMES_SIGN: &'static OperatorInfo<'static> = OPERATORS.get(&"Ã").unwrap();

	// IMPLIED_TIMES_HIGH_PRIORITY -- used in trig functions for things like sin 2x cos 2x where want > function app priority
	static ref IMPLIED_TIMES_HIGH_PRIORITY: OperatorInfo<'static> = OperatorInfo{
		ch: "\u{2062}", op_type: OperatorTypes::INFIX, priority: 851, next: None
	};
	static ref DEFAULT_OPERATOR_INFO_PREFIX: &'static OperatorInfo<'static> = &OperatorInfo{
		ch: "\u{E002}", op_type: OperatorTypes::PREFIX, priority: 260, next: None
	};
	static ref DEFAULT_OPERATOR_INFO_INFIX: &'static OperatorInfo<'static> = &OperatorInfo{
		ch: "\u{E002}", op_type: OperatorTypes::INFIX, priority: 260, next: None
	};
	static ref DEFAULT_OPERATOR_INFO_POSTFIX: &'static OperatorInfo<'static> = &OperatorInfo{
		ch: "\u{E002}", op_type: OperatorTypes::POSTFIX, priority: 260, next: None
	};

	// avoids having to use Option<OperatorInfo> in some cases
	static ref ILLEGAL_OPERATOR_INFO: &'static OperatorInfo<'static> = &OperatorInfo{
		ch: "\u{E003}", op_type: OperatorTypes::INFIX, priority: 999, next: None
	};
}

// fn verify_prefix_version(op: &'static OperatorInfo) -> &'static OperatorInfo {
// 	assert!(op.is_prefix());
// 	return op;
// }

struct StackInfo<'a,'o>{
	mrow: Element<'a>,	// mrow being built
	op: &'o OperatorInfo<'o>,	// last operator placed on stack
	is_operand: bool,		// true if child at end of mrow is an operand (as opposed to an operator)
}

impl<'a, 'o> StackInfo<'a, 'o> {
	fn new(doc: Document<'a>) -> StackInfo<'a, 'o> {
		// println!("  new empty StackInfo");
		let mrow = create_mathml_element(&doc, "mrow") ;
		mrow.set_attribute_value(CHANGED_ATTR, ADDED_ATTR_VALUE);
		return StackInfo{
			mrow,
			op: &LEFT_FENCEPOST,
			is_operand: false,
		}
	}

	fn with_op<'d>(doc: &'d Document<'a>, node: Element<'a>, op_info: &'o OperatorInfo<'o>) -> StackInfo<'a, 'o> {
		// println!("  new StackInfo with '{}' and operator {}/{}", name(&node), show_invisible_op_char(op_info), op_info.priority);
		let mrow = create_mathml_element(doc, "mrow");
		mrow.set_attribute_value(CHANGED_ATTR, ADDED_ATTR_VALUE);
		mrow.append_child(node);
		return StackInfo {
			mrow,
			op: op_info,
			is_operand: false,
		}
	}

	fn priority(&self) -> usize {
		return self.op.priority;
	}

	fn last_child_in_mrow(&self) -> Option<Element<'a>> {
		let children = self.mrow.children();
		if children.len() == 0 {
			return None
		} else {
			return Some( as_element(children[children.len() - 1]) );
		}
	}

	fn add_child_to_mrow(&mut self, child: Element<'a>, child_op: &'o OperatorInfo<'o>) {
		// println!("  adding '{}' to mrow[{}], operator '{}/{}'",
		// 			element_summary(child), self.mrow.children().len(), show_invisible_op_char(child_op), child_op.priority);
		self.mrow.append_child(child);
		if ptr_eq(child_op, *ILLEGAL_OPERATOR_INFO) {
			assert!(!self.is_operand); 	// should not have two operands in a row
			self.is_operand = true;
		} else {
			self.op = child_op;
			self.is_operand = false;
		}
	}

	fn remove_last_operand_from_mrow(&mut self) -> Element<'a> {
		let children = self.mrow.children();
		assert!( children.len() > 0 );
		assert!( self.is_operand || children.len()==1 );		// could be operator that is forced to be interpreted as operand -- eg, bad input like "x+("
		self.is_operand = false;
		let last_operand = as_element(children[children.len()-1]);
		// println!("  Removing last element '{}' from mrow[{}]",element_summary(last_operand), children.len());
		last_operand.remove_from_parent();
		return last_operand;
	}

}

fn top<'s, 'a:'s, 'o>(vec: &'s Vec<StackInfo<'a, 'o>>) -> &'s StackInfo<'a, 'o> {
	return &vec[vec.len()-1];
}


// Find the operator associated with the 'mo_node'
// This is complicated by potentially needing to distinguish between the
//   prefix, infix, or postfix version of the operator.
// To figure out prefix, we need to look at the node on the left; for postfix, we need to look to the left
// If the node of the left has been parsed, then this works.
// For example, suppose we want to determine if the "+" in 'x < n!+1' is prefix or infix.
//   If we simply looked left without parsing, we'd see an operator and choose prefix unless we could figure out that
//   that "!" was postfix.  But if it had been parsed, we'd see an mrow (operand) and tree "+" as infix (as it should).
// The same problem applies on the right for postfix operators, but a problem is rare for those
//   e.g., n!!n -- ((n!)!)*n or (n!)*(!n)  -- the latter doesn't make semantic sense though
// FIX:  the above ignores mspace and other nodes that need to be skipped to determine the right node to determine airity
// FIX:  the postfix problem above should be addressed
fn find_operator<'a, 'o>(mo_node: Element<'a>, previous_operator: Option<&'static OperatorInfo>,
					previous_node: Option<Element<'a>>, next_node: Option<Element<'a>>) -> &'o OperatorInfo<'o> {
	// get the unicode value and return the OpKeyword associated with it
	assert!( name(&mo_node) == "mo");

	// if a form has been given, that takes precedence
	let form = mo_node.attribute_value("form");
	let op_type =  match form {
		None => OperatorTypes::UNSPECIFIED,
		Some(form) => match form.to_lowercase().as_str() {
			"prefix" => OperatorTypes::PREFIX,
			"postfix" => OperatorTypes::POSTFIX,
			_ => OperatorTypes::INFIX,
		}
	};	

	let operator_str = as_text(mo_node);
	let found_op_info = OPERATORS.get(operator_str);
	// FIX: need to also deal with priority
	if found_op_info.is_none() {
		// no known operator -- return the unknown operator with the correct "fix" type
		return match op_type {
			OperatorTypes::UNSPECIFIED => &DEFAULT_OPERATOR_INFO_INFIX,
			OperatorTypes::PREFIX => &DEFAULT_OPERATOR_INFO_PREFIX,
			OperatorTypes::POSTFIX => &DEFAULT_OPERATOR_INFO_POSTFIX,
			_ => &DEFAULT_OPERATOR_INFO_INFIX,
		}
	}

	let op_info = found_op_info.unwrap();
	if op_type != OperatorTypes::UNSPECIFIED {
		return operator_info_given_op_type(op_info, op_type);
	}

	let op_versions = OperatorVersions::new(op_info);
	// based on choices, pick one that fits the context
	// if there isn't an obvious one, we have parsed the left, but not the right, so discount that

	// Trig functions have some special syntax
	// We need to to treat '-' as prefix for things like "sin -2x"
	// Need to be careful because (sin - cos)(x) needs an infix '-'
	// Return either the prefix or infix version of the operator
	if op_versions.infix.is_some() && next_node.is_some() &&
		is_function_name(get_possible_embellished_node(next_node.unwrap()), None) {
		return op_versions.infix.unwrap();
	}
	if op_versions.prefix.is_some() && previous_node.is_some() &&
		is_function_name(get_possible_embellished_node(previous_node.unwrap()), None) {
		return op_versions.prefix.unwrap();
	}

	// after that special case, start with the obvious cases...
	let operand_on_left = previous_operator.is_none() || previous_operator.unwrap().is_postfix();	// operand or postfix operator
	let operand_on_right = next_node.is_some() && name(&get_possible_embellished_node(next_node.unwrap())) !="mo";			// FIX:  could improve by checking if it is a prefix op

	if operand_on_left && operand_on_right && op_versions.infix.is_some() {
		return op_versions.infix.unwrap();	// infix
	} else if !operand_on_left && operand_on_right && op_versions.prefix.is_some() {
		return op_versions.prefix.unwrap();	// prefix
	} else if operand_on_left && op_versions.postfix.is_some() {
		// includes fall back case of discounting right side
		return op_versions.postfix.unwrap();	// postfix
	} else if op_versions.postfix.is_some() && op_versions.postfix.unwrap().is_right_fence() {
		// FIX: probably should make sure operator on right is left fence
		return op_versions.postfix.unwrap();	// postfix
	} else if operand_on_left && op_versions.infix.is_some() {
		return op_versions.infix.unwrap();	// fall back to infix
	} else {
		// for lack of anything better, just go with original (primary?) value
		return op_info;
	}

	fn operator_info_given_op_type<'o>(op_info: &'o OperatorInfo, op_type: OperatorTypes) -> &'o OperatorInfo<'o> {
		// mo specifies fix-type, so find the matching op_info
		if let Some(found_op_info) = match_operator_info(op_info, op_type) {
			return found_op_info;
		}

		// no match in regular -- see if we have already added it
		return MODIFIED_OPERATORS.with( |modified_operators | {
			let mut modified_operators = modified_operators.borrow_mut();
			let op_info_modified = modified_operators.get(op_info.ch);
			if let Some(op_info) = op_info_modified {
				if let Some(found_op_info) = match_operator_info(op_info, op_type) {
					return found_op_info;	
				}			
			}
	
			// not added already, so add it
			let mut new_op_info = op_info.clone();
			new_op_info.op_type = op_type;
			match op_info_modified {
				None => {modified_operators.insert(op_info.ch.to_string(),new_op_info);},
				Some(op_info_modified) => {
					let next_op_info = op_info_modified.next;
					new_op_info.next = next_op_info;
					op_info_modified.next = Some(&new_op_info);
				}
			}
			return &new_op_info;
		});

		fn match_operator_info<'o>(op_info: &'o OperatorInfo<'o>, op_type: OperatorTypes) -> Option<&'o OperatorInfo<'o>> {
			if op_info.is_operator_type(op_type) {
				return Some(op_info);
			}
			if let Some(next_op_info) = op_info.next {
				if next_op_info.is_operator_type(op_type) {
					return Some(&next_op_info);
				};
				if let Some(next_op_info)  = next_op_info.next {
					if next_op_info.is_operator_type(op_type) {
						return Some(&next_op_info);
					}
				}
			};
			return None;
		}
	}
	
}

fn n_vertical_bars_on_right<'a, 'o>(children: Vec<ChildOfElement>, vert_bar_op: &'o OperatorInfo) -> usize {
	// return the number of children that match 'vert_bar_op' not counting the first element
	let mut n = 0;
	for child_of_element in &children[1..] {
		let child = as_element(*child_of_element);
		if name(&child) == "mo" {
			let operator_str = as_text(child);
			if operator_str == vert_bar_op.ch {
				n += 1;
			}
		}
	}
	return n;
}


fn determine_vertical_bar_op<'a, 'o>(original_op: &'o OperatorInfo<'o>, mo_node: Element<'a>, 
			next_child: Option<Element<'a>>,
			parse_stack: &'a mut Vec<StackInfo>,
			n_vertical_bars_on_right: usize) -> &'o OperatorInfo<'o> {
	// if in a prefix location, it is a left fence
	// note:  if there is an operator on the top of the stack, it wants an operand (otherwise it would have been reduced)
	let operator_str = as_text(mo_node);
	let found_op_info = OPERATORS.get(operator_str);
	if found_op_info.is_none() {
		return original_op;
	}
	let op = found_op_info.unwrap();
	if !AMBIGUOUS_OPERATORS.contains(op.ch) {
		// println!("   op is not ambiguous");
		return original_op;
	};

	let operator_versions = OperatorVersions::new(op);
	if operator_versions.prefix.is_some() {
		if top(&parse_stack).last_child_in_mrow().is_none() || !top(&parse_stack).is_operand {
			// println!("   is prefix");
			return operator_versions.prefix.unwrap();
		}
	}
	
	// We have either a right fence or an infix operand at the top of the stack
	// If this is already parsed, we'd look to the right to see if there is an operand after this child.
	// But it isn't parsed and there might be a prefix operator which will eventually become an operand, so it is tricky.
	// It is even trickier because we might have an implicit times, so we can't really tell
	// For example:  |x|y|z| which can be '|x| y |z|' or '|x |y| z|', or even | (x|y)|z |'
	// We can't really know what is intended (without @intent).
	// It seems like the case where it could be paired with a matching vertical bar as what most people would choose, so we favor that.

	// If there is a matching open vertical bar, it is either at the top of the stack or the entry just below the top
	let mut has_left_match = ptr_eq(top(&parse_stack).op, operator_versions.prefix.unwrap());						// match at top of stack? (empty matching bars)
	if !has_left_match && parse_stack.len() > 2 {
		// matching op is below top (operand between matching bars) -- pop, peek, push
		let old_top = parse_stack.pop().unwrap();																			// can only access top, so we need to pop off top and push back later
		has_left_match = ptr_eq(top(&parse_stack).op, operator_versions.prefix.unwrap());
		parse_stack.push(old_top);
	}

	if operator_versions.postfix.is_some() && (next_child.is_none() || has_left_match) {
		// last child in row (must be a close) or we have a left match
		// println!("   is postfix");
		return operator_versions.postfix.unwrap();
	} else if next_child.is_none() {
		// operand on left, so prefer infix version
		return if operator_versions.infix.is_none() {op} else {operator_versions.infix.unwrap()};
	}

	let next_child = next_child.unwrap();
	if operator_versions.prefix.is_some() && (n_vertical_bars_on_right & 0x1 != 0) {
		// 	("   is prefix");
		return operator_versions.prefix.unwrap();		// odd number of vertical bars remain, so consider this the start of a pair
	}

	let next_child = get_possible_embellished_node(next_child);
	let next_child_op = if name(&next_child) != "mo" {
			None
		} else {
			let next_next_children = next_child.following_siblings();
			let next_next_child = if next_next_children.len() == 0 { None } else { Some( as_element(next_next_children[0]) )};
			Some( find_operator(next_child, operator_versions.infix,
								top(&parse_stack).last_child_in_mrow(), next_next_child) )
		};
											  
	// If the next child is a prefix op or a left fence, it will reduce to an operand, so don't consider it an operator
	if next_child_op.is_some() && !next_child_op.unwrap().is_left_fence() && !next_child_op.unwrap().is_prefix() {
		if operator_versions.postfix.is_some() {
			// println!("   is postfix");
			return operator_versions.postfix.unwrap();	
		}
	} else {
		if operator_versions.infix.is_some() {
			// println!("   is infix");
			return operator_versions.infix.unwrap();	
		}
	}

	// nothing good to match
	return op;
}

static CHEMICAL_ELEMENTS: phf::Set<&str> = phf_set! {
	"Ac", "Ag", "Al", "Am", "Ar", "As", "At", "Au", "B", "Ba", "Be", "Bh", "Bi", "Bk", "Br",
	"C", "Ca", "Cd", "Ce", "Cf", "Cl", "Cm", "Cn", "Co", "Cr", "Cs", "Cu", "Db", "Ds", "Dy", 
	"Er", "Es", "Eu", "F", "Fe", "Fl", "Fm", "Fr", "Ga", "Gd", "Ge",
	"H", "He", "Hf", "Hg", "Ho", "Hs", "I", "In", "Ir", "K", "Kr",
	"La", "Li", "Lr", "Lu", "Lv", "Mc", "Md", "Mg", "Mn", "Mo", "Mt", 
	"N", "Na", "Nb", "Nd", "Ne", "Nh", "Ni", "No", "Np", "O", "Og", "Os", 
	"P", "Pa", "Pb", "Pd", "Pm", "Po", "Pr", "Pt", "Pu",
	"Ra", "Rb", "Re", "Rf", "Rg", "Rh", "Rn", "Ru", 
	"S", "Sb", "Sc", "Se", "Sg", "Si", "Sm", "Sn", "Sr",
	"Ta", "Tb", "Tc", "Te", "Th", "Ti", "Tl", "Tm", "Ts", 
	"U", "V", "W", "Xe", "Y", "Yb", "Zn", "Zr"};

fn is_chemical_element<'a>(node: Element<'a>) -> bool {
	// FIX: allow name to be in an mrow (e.g., <mi>N</mi><mi>a</mi>
	let name = name(&node);
	if name != "mi" && name != "mtext" {
		return false;
	}

	let text = as_text(node);
	return CHEMICAL_ELEMENTS.contains(text);
}

// return true if 'node' is a chemical element and is followed by a state (solid, liquid, ...)
fn is_likely_chemical_state<'a>(node: Element<'a>, right_siblings:&[ChildOfElement]) -> bool {
	assert_eq!(name(&node.parent().unwrap().element().unwrap()), "mrow"); // should be here because we are parsing an mrow

	// println!("   is_likely_chemical_state: '{}'?",element_summary(node));

	
	// right side hasn't been parsed, so two cases to look at
	let next_sibling = as_element(right_siblings[0]);
	if name(&next_sibling) == "mrow" {
		return is_likely_chemical_state(node, next_sibling.children().as_slice());
	}

	if right_siblings.len() == 0 {
		return false;
	}

	if right_siblings.len() < 3 {  // need at least '(' state ')
		return false;
	}
	// println!("    ....have enough siblings");

	if !is_chemical_element(node) {
		return false;
	}
	// println!("    ....found chemical element");

	let left_paren = as_element(right_siblings[0]);
	let right_paren = as_element(right_siblings[2]);

	// take care of special case of bad MathML for "aq" (split across two tokens)
	if right_siblings.len() > 3 {
		// check to make sure right kind of leaves then check the contents
		let l_paren = as_element(right_siblings[0]);
		let a = as_element(right_siblings[1]);
		let q = as_element(right_siblings[2]);
		let r_paren = as_element(right_siblings[3]);
		if name(&l_paren) == "mo" &&
	       name(&a) == "mi" && as_text(a) == "a" && 
	       name(&q) == "mi" && as_text(a) == "q" &&
	       name(&r_paren) == "mo" {
			let l_paren = as_text(l_paren);
			let r_paren = as_text(r_paren);
			// since we matched 'a' and 'q' -- either is or isn't chem state
			return (l_paren == "(" && r_paren == ")") || (l_paren == "[" && r_paren == "]");
		}
	}

	if name(&left_paren) != "mo" || name(&right_paren) != "mo" {
		return false;
	}

	if !( (as_text(left_paren) == "(" && as_text(right_paren) == ")") ||
	      (as_text(left_paren) == "[" && as_text(right_paren) == "]") ) {
		return false;
	}

	// have (xxx) or [xxx] -- check for "s, "l", "g", "aq"
	let state_node = as_element(right_siblings[1]);
	let state = as_text(state_node);
	if state == "s" || state == "l" || state == "g" || state == "aq" {
		return true;
	}

	// wasn't one of the cases that make it a chemical state
	return false;
}

// Try to figure out whether an <mi> is a function name or note.
// There are two important cases depending upon whether parens/brackets are used or not.
// E.g, sin x and f(x)
// 1. If parens follow the name, then we use a more inclusive set of heuristics as it is more likely a function
// The heuristics used are:
//   - it is on the list of known function names (e.g., sin" and "log")
//   - it is on the list of likely function names (e.g, f, g, h)
//   - multi-char names that begin with a capital letter (e.g, "Tr")
//   - there is a single token inside the parens (why else would someone use parens), any name (e.g, a(x))
//
// 2. If there are no pares, then only names on the known function list are used (e.g., "sin x") 
fn is_function_name<'a>(node: Element<'a>, right_siblings: Option<&[ChildOfElement<'a>]>) -> bool {
	let base_of_name = get_possible_embellished_node(node);

	// actually only 'mi' should be legal here, but some systems used 'mtext' for multi-char variables
	let node_name = name(&base_of_name);
	if node_name != "mi" && node_name != "mtext" {
		return false;
	}

	let node_str = as_text(base_of_name);
	if node_str.len() == 0 {
		return false;
	}
	// println!("    is_function_name({}), {} following nodes", node_str, if right_siblings.is_none() {"No".to_string()} else {right_siblings.unwrap().len().to_string()});
	return crate::definitions::DEFINITIONS.with(|defs| {
		let names = defs.function_names.as_hashset().borrow();
		if names.contains(node_str) {
			return true;	// always treated as function names
		}

		if right_siblings.is_none() {
			return false;	// only accept known names, which is tested above
		}
		assert_eq!(name(&node.parent().unwrap().element().unwrap()), "mrow");
		let right_siblings = right_siblings.unwrap();
		if right_siblings.len() == 0 ||
			name(&as_element(right_siblings[0])) != "mo"  ||
			!is_left_paren(as_element(right_siblings[0]))
		{
			return false;
		}

		if is_likely_chemical_state(node, right_siblings) {
			// println!("    is_likely_chemical_state=true");
			return true;
		}

		let likely_names = defs.likely_function_names.as_hashset().borrow();
		if likely_names.contains(node_str) {
			return true;	// don't bother checking contents of parens, consider these as function names
		}

		if is_single_arg(right_siblings) {
			return true;	// if there is only a single arg, why else would you use parens?
		};

		// Names like "Tr" are likely function names, single letter names like "M" or "J" are iffy
		// This needs to be after the chemical state check above to rule out Cl(g), etc
		let mut chars = node_str.chars();
		let first_char = chars.next().unwrap();		// we know there is at least one byte in it, hence one char
		if chars.next().is_some() && first_char.is_uppercase() {
			return true;
		}

		return false;		// didn't fit one of the above categories
	});

	fn is_single_arg<'a>(following_nodes: &[ChildOfElement<'a>]) -> bool {
		if following_nodes.len() == 1 {
			return true;		// "a(" might or might not be a function call -- treat as "is" because we can't see more 
		}

		if is_right_paren(as_element(following_nodes[1])) {
			return true;		// no-arg case "a()"
		}

		return following_nodes.len() > 2 && is_right_paren(as_element(following_nodes[2]));
	}

	fn is_left_paren<'a>(node: Element<'a>) -> bool {
		let text = as_text(node);
		return text == "(" || text == "[";
	}

	fn is_right_paren<'a>(node: Element<'a>) -> bool {
		let text = as_text(node);
		return text == ")" || text == "]";
	}
}

fn is_mixed_fraction<'a>(integer_part: &'a Element<'a>, fraction_part: &'a Element<'a>) -> bool {
	if name(fraction_part) != "mfrac" {
		return false;
	}

	// integer part must be either 'n' or '-n' (in an mrow)
	let integer_part_name = name(integer_part);
	if integer_part_name == "mrow" {
		let children = integer_part.children();
		if children.len() == 2 &&
			name(&as_element(children[0])) == "mo" &&
			as_text(as_element(children[0])) == "-" {
				let integer_part = as_element(children[1]);
				if name(&integer_part) != "mn"  || as_text(integer_part).contains(DECIMAL_SEPARATOR) {
					return false;
				}
		}
	};

	if name(integer_part) != "mn"  || as_text(*integer_part).contains(DECIMAL_SEPARATOR) {
		return false;
	}

	// fraction_part needs to have integer numerator and denominator (already tested it is a frac)
	let fraction_children = fraction_part.children();
	if fraction_children.len() != 2 {
		return false;
	}
	let numerator = as_element(fraction_children[0]);
	if name(&numerator) != "mn" || as_text(numerator).contains(DECIMAL_SEPARATOR) {
		return false;
	}
	let denominator = as_element(fraction_children[1]);
	if name(&denominator) != "mn" || as_text(denominator).contains(DECIMAL_SEPARATOR) {
		return false;
	}

	return true;		// the only thing left is a mixed fraction
}

// Add the current operator if it's not n-ary to the stack
// 'current_child' and it the operator to the stack.
fn shift_stack<'s, 'a:'s, 'o>(parse_stack: &'s mut Vec<StackInfo<'a, 'o>>, current_child: Element<'a>, current_op: &'o OperatorInfo<'o>) -> (Element<'a>, &'o OperatorInfo<'o>) {
	let mut new_current_child = current_child;
	let mut new_current_op = current_op;
	let previous_op = top(&parse_stack).op;
	// println!(" shift_stack: shift on '{}'; ops: prev '{}/{}', cur '{}/{}'",
	// 		element_summary(current_child),show_invisible_op_char(previous_op), previous_op.priority,
	// 		show_invisible_op_char(current_op), current_op.priority);
	if !previous_op.is_nary(current_op) {
		// grab operand on top of stack (if there is one) and make it part of the new mrow since current op has higher precedence
		// if operators are the same and are binary, then this push makes them act as left associative
		let mut top_of_stack = parse_stack.pop().unwrap();
		if top_of_stack.mrow.children().len() == 0 || (!top_of_stack.is_operand && !current_op.is_right_fence()) {
			// "bad" syntax - no operand on left -- don't grab operand (there is none)
			//   just start a new mrow beginning with operator
			// FIX -- check this shouldn't happen:  parse_stack.push(top_of_stack);
			parse_stack.push( StackInfo::new(current_child.document()) );
		} else if current_op.is_right_fence() {
			// likely, but not necessarily, there is a left fence to start the mrow
			// this is like the postfix case except we grab the entire mrow, push on the close, and make that the mrow
			// note:  the code does these operations on the stack for consistency, but it could be optimized without push/popping the stack
			let mrow = top_of_stack.mrow;
			top_of_stack.add_child_to_mrow(current_child, current_op);
			new_current_op = *ILLEGAL_OPERATOR_INFO;							// treat matched brackets as operand
			new_current_child = mrow;	
			let children = mrow.children();
			if  children.len() == 2 &&
				( name(&as_element(children[0])) != "mo" ||
				  !find_operator(as_element(children[0]),
				  			 None, Some(as_element(children[0])), Some(mrow) ).is_left_fence()) {
				// the mrow did *not* start with an open (hence no push)
				// since parser really wants balanced parens to keep stack state right, we do a push here
				parse_stack.push( StackInfo::new(mrow.document()) );
			} else if children.len() <= 3 {
				// the mrow started with some open fence (which caused a push) -- add the close, pop, and push on the "operand"
			} else {
				panic!("Wrong number of children in mrow when handling a close fence");
			}
		} else if current_op.is_postfix() {
			// grab the left operand and start a new mrow with it and the operator -- put those pack on the stack
			// note:  the code does these operations on the stack for consistency, but it could be optimized without push/popping the stack
			let previous_child = top_of_stack.remove_last_operand_from_mrow();					// remove operand from mrow
			parse_stack.push(top_of_stack);
			let mut new_top_of_stack = StackInfo::with_op(&current_child.document(), previous_child, current_op); // begin new mrow with operand
			new_top_of_stack.add_child_to_mrow(current_child, current_op);	// add on operator
			new_current_child = new_top_of_stack.mrow;								// grab for pushing on old mrow
			new_current_op = *ILLEGAL_OPERATOR_INFO;								// treat "reduced" postfix operator & operand as an operand
		} else {
			// normal infix op case -- grab the left operand and start a new mrow with it and the operator
			let previous_child = top_of_stack.remove_last_operand_from_mrow();
			parse_stack.push(top_of_stack);
			parse_stack.push( StackInfo::with_op(&current_child.document(),previous_child, current_op) );
		}
	}
	return (new_current_child, new_current_op);
}


fn reduce_stack<'s, 'a:'s, 'o>(parse_stack: &'s mut Vec<StackInfo<'a, 'o>>, current_priority: usize, stop_at_function_call: bool) {
	// stop_at_function_call -- hack to to deal with exceptional parsing for things like "sin -2x" (see comments around call of reduce_stack)
	let mut prev_priority = top(&parse_stack).priority();
	// println!(" reduce_stack: stack len={}, priority: prev={}, cur={}", parse_stack.len(), prev_priority, current_priority);
	while current_priority < prev_priority {					// pop off operators until we are back to the right level
		if stop_at_function_call && ptr_eq(top(&parse_stack).op, *INVISIBLE_FUNCTION_APPLICATION) {
			break;
		}

		if parse_stack.len() == 1 {
			break;			// something went wrong -- break before popping too much
		}
		let mut top_of_stack = parse_stack.pop().unwrap();
		// println!(" ..popped len={} op:'{}/{}', operand: {}",
		// 		top_of_stack.mrow.children().len(),
		// 		show_invisible_op_char(top_of_stack.op), top_of_stack.op.priority,
		// 		top_of_stack.is_operand);
		let mut mrow = top_of_stack.mrow;
		if mrow.children().len() == 1 {
			// should have added at least operator and operand, but input might not be well-formed
			// in this case, unwrap the mrow and expose the single child for pushing onto stack
			let single_child = top_of_stack.remove_last_operand_from_mrow();
			mrow = single_child;
		}

		let mut top_of_stack = parse_stack.pop().unwrap();
		top_of_stack.add_child_to_mrow(mrow, *ILLEGAL_OPERATOR_INFO);	// mrow on top is "parsed" -- now add it to previous
		prev_priority = top_of_stack.priority();
		parse_stack.push(top_of_stack);
	};
}

fn is_trig_arg<'s, 'a:'s, 'o>(previous_child: Element<'a>, current_child: Element<'a>, parse_stack: &'s Vec<StackInfo<'a, 'o>>) -> bool {
	// We have operand-operand and know we want multiplication at this point. 
	// Check for special case where we want multiplication to bind more tightly than function app (e.g, sin 2x, sin -2xy)
	// We only want to do this for simple args
	use crate::xpath_functions::IsNode;
	// println!("  is_trig_arg: prev {}, current {}, stack len={}; top len={}",
		//  element_summary(previous_child), element_summary(current_child),
		//  parse_stack.len(), top(parse_stack).mrow.children().len());
	if !IsNode::is_simple(&current_child) {
		return false;
	}
	// This only matters if we are not inside of parens
	if IsBracketed::is_bracketed(&previous_child, "(", ")", false) ||
	   IsBracketed::is_bracketed(&previous_child, "[", "]", false) {
		return false;
	}

	// Use lower priority multiplication if current_child is a function (e.g. "cos" in "sin x cos 3y")
	if is_function_name(current_child, None) {
		return false;
	}

	// Two cases:
	// 1. First operand-operand (e.g, sin 2x, where 'current_child' is 'x') -- top of stack is 'sin' 'apply func' '2'
	// 2. Subsequent operand-operand (e.g, sin 2xy, where 'current_child' is 'y') -- top of stack is '2' 'times' 'x'
	let op_on_top = top(&parse_stack).op;
 	return ptr_eq(op_on_top, *INVISIBLE_FUNCTION_APPLICATION) || ptr_eq(op_on_top, &*IMPLIED_TIMES_HIGH_PRIORITY);
}


/*
	canonicalize_mrows_in_mrow is a simple(ish) operator precedence parser.
	It works by keeping a stack of 'StackInfo':
	'StackInfo' has three parts:
	1. the mrow being build
	2. info about the operator in the mrow being build
	3. bool to say whether the last thing is an operator or an operand

	When the op priority increases (eg, have "=" and get "+"), we push on
	1. a new mrow -- if the operator has a left operand, we remove the last node in the mrow and it becomes
	   the first (only so far) child of the new mrow
	2. the operator info

	When the op priority decreases, we do the following loop until the this new priority > priority on top of stack
	1. pop the StackInfo
	2. add the StackInfo's mrow  as the last child to the new top of the stack
	We also do this when we hit the end of the mrow (we can treat this case as if we have a negative precedence)

	+/- are treated as nary operators and don't push/pop in those cases.
	consecutive operands such as nary times are also considered n-ary operators and don't push/pop in those cases.
*/
fn canonicalize_mrows_in_mrow<'a>(mrow: Element<'a>) -> Result<Element<'a>> {
	let saved_mrow_attrs = mrow.attributes();	
	assert_eq!(name(&mrow), "mrow");
	let children = mrow.children();
	// println!("canonicalize_mrows_in_mrow: mrow len={}", children.len());
	if children.len() == 1 {
		return Ok(add_attrs_back(canonicalize_mrows(as_element(children[0]))?, saved_mrow_attrs));
	}


	// FIX: don't touch/canonicalize
	// 1. if intent is given -- anything intent references
	// 2. if the mrow starts or ends with a fence, don't merge into parent (parse children only) -- allows for "]a,b["
	let mut parse_stack = vec![];
	parse_stack.push(StackInfo::new(mrow.document()));
	let children = mrow.children();
	let num_children = children.len();
	for i_child in 0..num_children {
		// println!("\nDealing with child # {}", i_child);
		let mut current_child = canonicalize_mrows(as_element(children[i_child]))?;
		let base_of_child = get_possible_embellished_node(current_child);
		let mut current_op = *ILLEGAL_OPERATOR_INFO; // avoids using Option<>

		// figure what the current operator is -- it either comes from the 'mo' (if we have an 'mo') or it is implied
		if name(&base_of_child) == "mo" && base_of_child.children().len() > 0 { // shouldn't have empty mo node, but...
			let previous_op = if top(&mut parse_stack).is_operand {None} else {Some( top(&parse_stack).op )};
			let next_node = if i_child + 1 < num_children {Some(as_element(children[i_child+1]))} else {None};
			current_op = find_operator(base_of_child, previous_op,
						top(&parse_stack).last_child_in_mrow(), next_node);

			// deal with vertical bars which might be infix, open, or close fences
			// note: mrow shrinks as we iterate through it (removing children from it)
			current_op = determine_vertical_bar_op(
				current_op,
				base_of_child,
				next_node,
				&mut parse_stack,
				n_vertical_bars_on_right(mrow.children(), current_op)
			);
		} else if top(&parse_stack).last_child_in_mrow().is_some() {
			let previous_child = top(&parse_stack).last_child_in_mrow().unwrap();
			let base_of_previous_child = get_possible_embellished_node(previous_child);
			if name(&base_of_previous_child) != "mo" {
				// consecutive operands -- choose either implicit multiplication or implicit function application
				// let is_bracketed_expr = IsBracketed::is_bracketed(&current_child, "(", ")", false) ||
				// 							 IsBracketed::is_bracketed(&current_child, "[", "]", false);
				current_op = if is_function_name(previous_child, Some(&children[i_child..])) {
							&*INVISIBLE_FUNCTION_APPLICATION
						} else if is_mixed_fraction(&previous_child, &current_child) {
							&*IMPLIED_INVISIBLE_PLUS
						} else if is_trig_arg(base_of_previous_child, base_of_child, &parse_stack) {
							&*IMPLIED_TIMES_HIGH_PRIORITY				  
						} else {
							&*IMPLIED_TIMES
						};


				// println!("  Found implicit op {}/{}", show_invisible_op_char(current_op), current_op.priority);
				reduce_stack(&mut parse_stack, current_op.priority, !is_function_name(base_of_child, None));

				let implied_mo = create_mo(current_child.document(), current_op);
				let shift_result = shift_stack(&mut parse_stack, implied_mo, current_op);
				// ignore shift_result.0 which is just 'implied_mo'
				assert_eq!(implied_mo, shift_result.0);
				assert!( ptr_eq(current_op, shift_result.1) );
				let mut top_of_stack = parse_stack.pop().unwrap();
				top_of_stack.add_child_to_mrow(implied_mo, current_op);
				parse_stack.push(top_of_stack);
			}
			current_op = &ILLEGAL_OPERATOR_INFO;
		}

		if !ptr_eq(current_op, *ILLEGAL_OPERATOR_INFO) {
			if current_op.is_left_fence() || current_op.is_prefix() {
				if top(&parse_stack).is_operand {
					// will end up with operand operand -- need to choose operator associated with prev child
					// we use the original input here because in this case, we need to look to the right of the ()s to deal with chemical states
					let implied_operator = if is_function_name(as_element(children[i_child-1]),
																Some(&children[i_child..])) {
						 	*INVISIBLE_FUNCTION_APPLICATION
						} else {
							*IMPLIED_TIMES
						};
					// println!("  adding implied {}", if ptr_eq(implied_operator,*IMPLIED_TIMES) {"times"} else {"function apply"});

					let implied_mo = create_mo(current_child.document(), implied_operator);
					let shift_result = shift_stack(&mut parse_stack, implied_mo, implied_operator);
					// ignore shift_result.0 which is just 'implied_mo'
					assert_eq!(implied_mo, shift_result.0);
					assert!( ptr_eq(implied_operator, shift_result.1) );
					let mut top_of_stack = parse_stack.pop().unwrap();
					top_of_stack.add_child_to_mrow(implied_mo, implied_operator);
					parse_stack.push(top_of_stack);
				}
				// starting a new mrow
				parse_stack.push( StackInfo::new(current_child.document()) );
			} else {
				// One of infix, postfix, or right fence -- all should have a left operand
				// pop the stack if it is lower precedence (it forms an mrow)
				reduce_stack(&mut parse_stack, current_op.priority, false);
				// push new operator on stack (already handled n-ary case)
				let shift_result = shift_stack(&mut parse_stack, current_child, current_op);
				current_child = shift_result.0;
				current_op = shift_result.1;
			}
		}
		let mut top_of_stack = parse_stack.pop().unwrap();
		top_of_stack.add_child_to_mrow(current_child, current_op);
		parse_stack.push(top_of_stack);
	}

	// Reached the end -- force reduction of what's left on the stack
	reduce_stack(&mut parse_stack, LEFT_FENCEPOST.priority, false);

	// We essentially have 'terminator( mrow terminator)'
	//   in other words, we have an extra mrow with one child due to the initial start -- remove it
	let mut top_of_stack = parse_stack.pop().unwrap();
	assert_eq!(parse_stack.len(), 0);

	let mut parsed_mrow = top_of_stack.mrow;
	assert_eq!( name(&top_of_stack.mrow), "mrow");
	if parsed_mrow.children().len() == 1 {
		parsed_mrow = top_of_stack.remove_last_operand_from_mrow();
		// was synthesized, but is really the original top level mrow
	}

	parsed_mrow.remove_attribute(CHANGED_ATTR);
	return Ok( add_attrs_back(parsed_mrow, saved_mrow_attrs) );

	fn add_attrs_back<'a>(mrow: Element<'a>, attrs: Vec<Attribute>) -> Element<'a> {
		// println!(   "Adding back {} attr(s)", attrs.len());
		for attr in attrs {
			mrow.set_attribute_value(attr.name(), attr.value());
		}
		return mrow;
	}
}


#[cfg(test)]
mod tests {
    use super::*;
    use sxd_document::parser;


    fn are_strs_canonically_equal(test: &str, target: &str) -> bool {
		// this forces initialization
		crate::speech::SPEECH_RULES.with(|_| true);

        let package1 = &parser::parse(test).expect("Failed to parse test input");
		let mathml = crate::interface::get_element(package1);
		crate::interface::trim_element(&mathml);
		let mathml_test = canonicalize(mathml);
        
        let package2 = &parser::parse(target).expect("Failed to parse target input");
		let mathml_target = crate::interface::get_element(package2);
		crate::interface::trim_element(&mathml_target);
            
        return crate::interface::is_same_element(&mathml_test, &mathml_target);
    }

    #[test]
    fn canonical_same() {
        let target_str = "<math><mrow><mo>-</mo><mi>a</mi></mrow></math>";
        assert!(are_strs_canonically_equal(target_str, target_str));
    }

    #[test]
    fn canonical_one_element_mrow_around_mrow() {
        let test_str = "<math><mrow><mrow><mo>-</mo><mi>a</mi></mrow></mrow></math>";
        let target_str = "<math><mrow><mo>-</mo><mi>a</mi></mrow></math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }

    #[test]
    fn canonical_one_element_mrow_around_mo() {
        let test_str = "<math><mrow><mrow><mo>-</mo></mrow><mi>a</mi></mrow></math>";
        let target_str = "<math><mrow><mo>-</mo><mi>a</mi></mrow></math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }

    #[test]
    fn canonical_flat_to_times_and_plus() {
        let test_str = "<math><mi>c</mi><mo>+</mo><mi>x</mi><mi>y</mi></math>";
        let target_str = "<math>
		<mrow data-changed='added'><mi>c</mi><mo>+</mo>
		  <mrow data-changed='added'><mi>x</mi><mo data-changed='added'>&#x2062;</mo><mi>y</mi></mrow>
		</mrow></math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }

    #[test]
    fn canonical_prefix_and_infix() {
        let test_str = "<math><mrow><mo>-</mo><mi>a</mi><mo>-</mo><mi>b</mi></mrow></math>";
        let target_str = "<math>
		<mrow>
		  <mrow data-changed='added'>
			<mo>-</mo>
			<mi>a</mi>
		  </mrow>
		  <mo>-</mo>
		  <mi>b</mi>
		</mrow>
	   </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }

    #[test]
    fn function_with_single_arg() {
        let test_str = "<math><mrow>
		<mi>sin</mi><mo>(</mo><mi>x</mi><mo>)</mo>
			<mo>+</mo>
		 <mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo>
			<mo>+</mo>
		 <mi>t</mi><mrow><mo>(</mo><mi>x</mi><mo>)</mo></mrow>
		</mrow></math>";
        let target_str = "<math>
		<mrow>
		  <mrow data-changed='added'>
			<mi>sin</mi>
			<mo data-changed='added'>&#x2061;</mo>
			<mrow data-changed='added'>
			  <mo>(</mo>
			  <mi>x</mi>
			  <mo>)</mo>
			</mrow>
		  </mrow>
		  <mo>+</mo>
		  <mrow data-changed='added'>
			<mi>f</mi>
			<mo data-changed='added'>&#x2061;</mo>
			<mrow data-changed='added'>
			  <mo>(</mo>
			  <mi>x</mi>
			  <mo>)</mo>
			</mrow>
		  </mrow>
		  <mo>+</mo>
		  <mrow data-changed='added'>
			<mi>t</mi>
			<mo data-changed='added'>&#x2062;</mo>
			<mrow>
			  <mo>(</mo>
			  <mi>x</mi>
			  <mo>)</mo>
			</mrow>
		  </mrow>
		</mrow>
	   </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }

    #[test]
    fn function_with_multiple_args() {
        let test_str = "<math>
		<mi>sin</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo>
			<mo>+</mo>
		 <mi>f</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo>
			<mo>+</mo>
		 <mi>t</mi><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo></mrow>
		</math>";
        let target_str = " <math>
		<mrow data-changed='added'>
		<mrow data-changed='added'>
		  <mi>sin</mi>
		  <mo data-changed='added'>&#x2061;</mo>
		  <mrow data-changed='added'>
			<mo>(</mo>
			<mrow data-changed='added'>
			  <mi>x</mi>
			  <mo>+</mo>
			  <mi>y</mi>
			</mrow>
			<mo>)</mo>
		  </mrow>
		</mrow>
		<mo>+</mo>
		<mrow data-changed='added'>
		  <mi>f</mi>
		  <mo data-changed='added'>&#x2061;</mo>
		  <mrow data-changed='added'>
			<mo>(</mo>
			<mrow data-changed='added'>
			  <mi>x</mi>
			  <mo>+</mo>
			  <mi>y</mi>
			</mrow>
			<mo>)</mo>
		  </mrow>
		</mrow>
		<mo>+</mo>
		<mrow data-changed='added'>
		  <mi>t</mi>
		  <mo data-changed='added'>&#x2062;</mo>
		  <mrow>
			<mo>(</mo>
			<mrow data-changed='added'>
			  <mi>x</mi>
			  <mo>+</mo>
			  <mi>y</mi>
			</mrow>
			<mo>)</mo>
			</mrow>
		  </mrow>
		</mrow>
	   </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }

    #[test]
    fn function_with_no_args() {
        let test_str = "<math><mrow>
		<mi>sin</mi><mi>x</mi>
			<mo>+</mo>
		 <mi>f</mi><mi>x</mi>
			<mo>+</mo>
		 <mi>t</mi><mi>x</mi>
		</mrow></math>";
        let target_str = " <math>
		<mrow>
		  <mrow data-changed='added'>
			<mi>sin</mi>
			<mo data-changed='added'>&#x2061;</mo>
			<mi>x</mi>
		  </mrow>
		  <mo>+</mo>
		  <mrow data-changed='added'>
			<mi>f</mi>
			<mo data-changed='added'>&#x2062;</mo>
			<mi>x</mi>
		  </mrow>
		  <mo>+</mo>
		  <mrow data-changed='added'>
			<mi>t</mi>
			<mo data-changed='added'>&#x2062;</mo>
			<mi>x</mi>
		  </mrow>
		</mrow>
	   </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));

	}


    #[test]
    fn implied_plus() {
        let test_str = "<math><mrow>
    <mn>2</mn><mfrac><mn>3</mn><mn>4</mn></mfrac>
    </mrow></math>";
        let target_str = "<math>
		<mrow>
			<mn>2</mn>
			<mo data-changed='added'>&#x2064;</mo>
			<mfrac>
				<mn>3</mn>
				<mn>4</mn>
			</mfrac>
		</mrow>
	</math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }


    #[test]
    fn vertical_bars() {
        let test_str = "<math>
		<mo>|</mo> <mi>x</mi> <mo>|</mo><mo>+</mo><mo>|</mo>
		 <mi>a</mi><mo>+</mo><mn>1</mn> <mo>|</mo>
	  </math>";
	  let target_str = " <math>
	  <mrow data-changed='added'>
		<mrow data-changed='added'>
		  <mo>|</mo>
		  <mi>x</mi>
		  <mo>|</mo>
		</mrow>
		<mo>+</mo>
		<mrow data-changed='added'>
		  <mo>|</mo>
		  <mrow data-changed='added'>
			<mi>a</mi>
			<mo>+</mo>
			<mn>1</mn>
		  </mrow>
		  <mo>|</mo>
		</mrow>
	  </mrow>
	 </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }


    #[test]
    fn vertical_bars_nested() {
        let test_str = "<math><mo>|</mo><mi>x</mi><mo>|</mo><mi>y</mi><mo>|</mo><mi>z</mi><mo>|</mo></math>";
	  let target_str = "<math>
	  <mrow data-changed='added'>
		<mrow data-changed='added'>
			<mo>|</mo>
			<mi>x</mi>
			<mo>|</mo>
		</mrow>
		<mo data-changed='added'>&#x2062;</mo>
		<mi>y</mi>
		<mo data-changed='added'>&#x2062;</mo>
		<mrow data-changed='added'>
			<mo>|</mo>
			<mi>z</mi>
			<mo>|</mo>
		</mrow>
	  </mrow>
	 </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }


    #[test]
    fn trig_args() {
        let test_str = "<math><mi>sin</mi><mn>2</mn><mi>x</mi><mi>cos</mi><mn>3</mn><mi>y</mi></math>";
        let target_str = "<math>
		<mrow data-changed='added'>
		  <mrow data-changed='added'>
			<mi>sin</mi>
			<mo data-changed='added'>&#x2061;</mo>
			<mrow data-changed='added'>
			  <mn>2</mn>
			  <mo data-changed='added'>&#x2062;</mo>
			  <mi>x</mi>
			</mrow>
		  </mrow>
		  <mo data-changed='added'>&#x2062;</mo>
		  <mrow data-changed='added'>
			<mi>cos</mi>
			<mo data-changed='added'>&#x2061;</mo>
			<mrow data-changed='added'>
			  <mn>3</mn>
			  <mo data-changed='added'>&#x2062;</mo>
			  <mi>y</mi>
			</mrow>
		  </mrow>
		</mrow>
	   </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }
    #[test]
    fn trig_negative_args() {
        let test_str = "<math><mi>sin</mi><mo>-</mo><mn>2</mn><mi>Ï</mi><mi>x</mi></math>";
        let target_str = "<math>
		<mrow data-changed='added'>
		  <mi>sin</mi>
		  <mo data-changed='added'>&#x2061;</mo>
		  <mrow data-changed='added'>
			<mrow data-changed='added'>
			  <mo>-</mo>
			  <mn>2</mn>
			</mrow>
			<mo data-changed='added'>&#x2062;</mo>
			<mi>Ï</mi>
			<mo data-changed='added'>&#x2062;</mo>
			<mi>x</mi>
		  </mrow>
		</mrow>
	   </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }

    #[test]
    fn trig_function_composition() {
        let test_str = "<math><mo>(</mo><mi>sin</mi><mo>-</mo><mi>cos</mi><mo>)</mo><mi>x</mi></math>";
        let target_str = "<math>
		<mrow data-changed='added'>
		  <mrow data-changed='added'>
			<mo>(</mo>
			<mrow data-changed='added'>
			  <mi>sin</mi>
			  <mo>-</mo>
			  <mi>cos</mi>
			</mrow>
			<mo>)</mo>
		  </mrow>
		  <mo data-changed='added'>&#x2062;</mo>
		  <mi>x</mi>
		</mrow>
	   </math>";
        assert!(are_strs_canonically_equal(test_str, target_str));
    }


}
